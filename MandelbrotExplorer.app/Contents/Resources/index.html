<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<title>Mandelbrot Explorer</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }

body {
    display: flex;
    width: 100vw;
    height: 100vh;
    background: #1a1a2e;
    color: #e0e0e0;
    font-family: 'SF Mono', 'Menlo', monospace;
    font-size: 12px;
    overflow: hidden;
}

#canvas-container {
    flex: 1;
    position: relative;
    background: #000;
}

canvas {
    width: 100%;
    height: 100%;
    display: block;
    cursor: crosshair;
}

#panel {
    width: 320px;
    min-width: 320px;
    background: #16213e;
    border-left: 1px solid #0f3460;
    display: flex;
    flex-direction: column;
    overflow: hidden;
}

/* Tabs */
#tabs {
    display: flex;
    border-bottom: 1px solid #0f3460;
}
.tab-btn {
    flex: 1;
    padding: 10px;
    background: transparent;
    border: none;
    color: #888;
    cursor: pointer;
    font-family: inherit;
    font-size: 12px;
    letter-spacing: 1px;
    text-transform: uppercase;
    transition: all 0.2s;
}
.tab-btn.active {
    color: #e94560;
    border-bottom: 2px solid #e94560;
    margin-bottom: -1px;
}
.tab-btn:hover { color: #e0e0e0; }

/* Panel-Inhalte */
.tab-content { display: none; flex: 1; flex-direction: column; overflow-y: auto; padding: 12px; gap: 12px; }
.tab-content.active { display: flex; }

.section-label {
    font-size: 10px;
    text-transform: uppercase;
    letter-spacing: 2px;
    color: #e94560;
    margin-bottom: 4px;
}

select, textarea, input[type="range"] {
    width: 100%;
    background: #0f3460;
    border: 1px solid #1a4a8a;
    color: #e0e0e0;
    border-radius: 4px;
    padding: 6px 8px;
    font-family: inherit;
    font-size: 11px;
}

textarea {
    resize: vertical;
    min-height: 80px;
    line-height: 1.5;
}

button.apply-btn {
    width: 100%;
    padding: 8px;
    background: #e94560;
    border: none;
    border-radius: 4px;
    color: white;
    cursor: pointer;
    font-family: inherit;
    font-size: 12px;
    letter-spacing: 1px;
    transition: background 0.2s;
}
button.apply-btn:hover { background: #c73652; }

.error-box {
    background: #3a1020;
    border: 1px solid #e94560;
    border-radius: 4px;
    padding: 8px;
    font-size: 10px;
    color: #ff8080;
    display: none;
    white-space: pre-wrap;
    word-break: break-all;
}

.info-box {
    background: #0a1628;
    border: 1px solid #0f3460;
    border-radius: 4px;
    padding: 10px;
    line-height: 2;
}
.info-row { display: flex; justify-content: space-between; }
.info-label { color: #888; }
.info-value { color: #4fc3f7; font-weight: bold; }

.slider-group { display: flex; flex-direction: column; gap: 4px; }
.slider-label { display: flex; justify-content: space-between; }
</style>
</head>
<body>

<div id="canvas-container">
    <canvas id="glCanvas"></canvas>
</div>

<div id="panel">
    <div id="tabs">
        <button class="tab-btn active" data-tab="tab2d">2D Mandelbrot</button>
        <button class="tab-btn" data-tab="tab3d">3D Mandelbulb</button>
    </div>

    <!-- 2D Panel -->
    <div id="tab2d" class="tab-content active">
        <div>
            <div class="section-label">Preset</div>
            <select id="preset-select">
                <option value="mandelbrot">Mandelbrot (z² + c)</option>
                <option value="burning-ship">Burning Ship</option>
                <option value="tricorn">Tricorn</option>
                <option value="multibrot3">Multibrot z³ + c</option>
                <option value="custom">[Eigener Code]</option>
            </select>
        </div>
        <div>
            <div class="section-label">Formel (GLSL)</div>
            <textarea id="formula-editor" rows="5" spellcheck="false"></textarea>
        </div>
        <div>
            <div class="section-label">Colorizer (GLSL)</div>
            <textarea id="colorizer-editor-2d" rows="5" spellcheck="false"></textarea>
        </div>
        <div>
            <div class="section-label">Max. Iterationen</div>
            <div class="slider-group">
                <div class="slider-label">
                    <span>Iterationen</span>
                    <span id="iter-val">256</span>
                </div>
                <input type="range" id="max-iter" min="64" max="2048" step="64" value="256">
            </div>
        </div>
        <button class="apply-btn" id="apply-2d">&#9654; Apply</button>
        <div class="error-box" id="error-2d"></div>
        <div>
            <div class="section-label">Info</div>
            <div class="info-box">
                <div class="info-row"><span class="info-label">Re</span><span class="info-value" id="info-re">-0.5</span></div>
                <div class="info-row"><span class="info-label">Im</span><span class="info-value" id="info-im">0.0</span></div>
                <div class="info-row"><span class="info-label">Zoom</span><span class="info-value" id="info-zoom">1.00</span></div>
            </div>
        </div>
    </div>

    <!-- 3D Panel -->
    <div id="tab3d" class="tab-content">
        <div>
            <div class="section-label">Exponent n</div>
            <div class="slider-group">
                <div class="slider-label"><span>n</span><span id="bulb-n-val">8</span></div>
                <input type="range" id="bulb-n" min="2" max="12" step="1" value="8">
            </div>
        </div>
        <div>
            <div class="section-label">Max. Iterationen</div>
            <div class="slider-group">
                <div class="slider-label"><span>Iterationen</span><span id="bulb-iter-val">8</span></div>
                <input type="range" id="bulb-iter" min="4" max="64" step="4" value="8">
            </div>
        </div>
        <div>
            <div class="section-label">AO-Stärke</div>
            <div class="slider-group">
                <div class="slider-label"><span>AO</span><span id="bulb-ao-val">0.50</span></div>
                <input type="range" id="bulb-ao" min="0" max="1" step="0.05" value="0.5">
            </div>
        </div>
        <div>
            <div class="section-label">Colorizer (GLSL)</div>
            <textarea id="colorizer-editor-3d" rows="5" spellcheck="false"></textarea>
        </div>
        <button class="apply-btn" id="apply-3d">&#9654; Apply</button>
        <div class="error-box" id="error-3d"></div>
        <div>
            <div class="section-label">Info</div>
            <div class="info-box">
                <div class="info-row"><span class="info-label">Renderzeit</span><span class="info-value" id="info-render">–</span></div>
            </div>
        </div>
    </div>
</div>

<script>
// ============================================================
// Globaler Zustand
// ============================================================
const canvas = document.getElementById('glCanvas');
const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
if (!gl) { alert('WebGL wird nicht unterstützt'); }

let currentMode = '2d';  // '2d' | '3d'
let program2d = null;
let program3d = null;
let quadBuffer = null;

// 2D-Zustand
let center = { x: -0.5, y: 0.0 };
let zoom = 1.0;
let maxIter2d = 256;

// 3D-Zustand
let bulbN = 8.0;
let bulbIter = 8;
let bulbAO = 0.5;
let camera = { theta: 0.5, phi: 0.3, dist: 3.5 };

// Perturbationstheorie (2D Präzision)
let programPerturb = null;
let orbitTex = null;
let orbitValid = false;
let isDefaultFormula = true;
let perturbAvailable = false;

// ============================================================
// Hilfsfunktionen: Shader compilieren
// ============================================================
function compileShader(type, src) {
    const sh = gl.createShader(type);
    gl.shaderSource(sh, src);
    gl.compileShader(sh);
    if (!gl.getShaderParameter(sh, gl.COMPILE_STATUS)) {
        const err = gl.getShaderInfoLog(sh);
        gl.deleteShader(sh);
        throw new Error(err);
    }
    return sh;
}

function linkProgram(vsSrc, fsSrc) {
    const vs = compileShader(gl.VERTEX_SHADER, vsSrc);
    const fs = compileShader(gl.FRAGMENT_SHADER, fsSrc);
    const prog = gl.createProgram();
    gl.attachShader(prog, vs);
    gl.attachShader(prog, fs);
    gl.linkProgram(prog);
    if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
        const err = gl.getProgramInfoLog(prog);
        gl.deleteProgram(prog);
        throw new Error(err);
    }
    return prog;
}

// ============================================================
// Fullscreen-Quad (bleibt für beide Modi)
// ============================================================
function initQuad() {
    quadBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        -1,-1,  1,-1,  -1,1,  1,1
    ]), gl.STATIC_DRAW);
}

function bindQuad(program) {
    gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
    const loc = gl.getAttribLocation(program, 'a_pos');
    gl.enableVertexAttribArray(loc);
    gl.vertexAttribPointer(loc, 2, gl.FLOAT, false, 0, 0);
}

// ============================================================
// Vertex-Shader (gleich für 2D und 3D)
// ============================================================
const VS_SRC = `
attribute vec2 a_pos;
void main() { gl_Position = vec4(a_pos, 0.0, 1.0); }
`;

// ============================================================
// Hilfsfunktionen für GLSL-Strings (in beide Shader eingebettet)
// ============================================================
const GLSL_HELPERS = `
vec3 hsv2rgb(vec3 c) {
    vec4 K = vec4(1.0, 2.0/3.0, 1.0/3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}
`;

// ============================================================
// 2D-Shader aufbauen
// ============================================================
const DEFAULT_FORMULA = `vec2 formula(vec2 z, vec2 c) {
    return vec2(z.x*z.x - z.y*z.y + c.x,
                2.0*z.x*z.y        + c.y);
}`;

const DEFAULT_COLORIZER_2D = `vec3 colorize(float t) {
    return hsv2rgb(vec3(t * 3.0 + 0.6, 0.85, sqrt(t)));
}`;

function build2dFragSrc(formulaSrc, colorizerSrc) {
    return `
precision highp float;
uniform vec2  u_res;
uniform vec2  u_cx;     // double-single: (hi, lo)
uniform vec2  u_cy;     // double-single: (hi, lo)
uniform float u_zoom;
uniform int   u_maxIter;

${GLSL_HELPERS}

// Double-Single: exakte Summe zweier floats → (s, err)
vec2 twoSum(float a, float b) {
    float s = a + b;
    float v = s - a;
    return vec2(s, (a - (s - v)) + (b - v));
}

${formulaSrc}

${colorizerSrc}

void main() {
    vec2 uv = (gl_FragCoord.xy / u_res - 0.5) * 2.0;
    uv.x *= u_res.x / u_res.y;
    float delta = 0.5 / u_zoom;

    // Hochpräzise Startkoordinaten (double-single Arithmetik)
    vec2 ts;
    ts = twoSum(u_cx.x, uv.x * delta); ts.y += u_cx.y;
    float cx = ts.x;
    ts = twoSum(u_cy.x, uv.y * delta); ts.y += u_cy.y;
    float cy = ts.x;
    vec2 c = vec2(cx, cy);

    vec2 z = vec2(0.0);
    float t = 0.0;
    bool escaped = false;
    for (int i = 0; i < 4096; i++) {
        if (i >= u_maxIter) break;
        z = formula(z, c);
        float r2 = dot(z, z);
        if (r2 > 256.0) {
            // Smooth coloring (Bernstein)
            float smooth = float(i) + 1.0 - log2(log2(sqrt(r2)));
            t = clamp(smooth / float(u_maxIter), 0.0, 1.0);
            escaped = true;
            break;
        }
    }
    if (!escaped) {
        gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
    } else {
        gl_FragColor = vec4(colorize(t), 1.0);
    }
}`;
}

// ============================================================
// 2D-Shader kompilieren
// ============================================================
function compile2d(formulaSrc, colorizerSrc) {
    if (program2d) gl.deleteProgram(program2d);
    program2d = linkProgram(VS_SRC, build2dFragSrc(formulaSrc, colorizerSrc));
}

// ============================================================
// Perturbationstheorie: Orbit-Textur + Shader
// ============================================================
// Referenz-Orbit am Mittelpunkt in JS float64 berechnen und in
// eine Float32-Textur hochladen. Der Shader iteriert nur noch δ.
function computeOrbit() {
    if (!perturbAvailable) return;
    orbitValid = false;
    const n = maxIter2d;
    const cx = center.x, cy = center.y;
    const data = new Float32Array(n * 4);   // RGBA: (Zx, Zy, 0, 0)
    let zx = 0, zy = 0;
    for (let i = 0; i < n; i++) {
        data[i * 4]     = zx;
        data[i * 4 + 1] = zy;
        const nx = zx * zx - zy * zy + cx;
        zy = 2 * zx * zy + cy;
        zx = nx;
        if (zx * zx + zy * zy > 65536) return;  // Orbit entkommen → kein Perturb
    }
    // Orbit vollständig → in Textur laden
    if (!orbitTex) orbitTex = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, orbitTex);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, n, 1, 0, gl.RGBA, gl.FLOAT, data);
    gl.bindTexture(gl.TEXTURE_2D, null);
    orbitValid = true;
}

// Perturbations-Shader: δ_{n+1} = 2·Z_n·δ_n + δ_n² + Δc
function build2dPerturbFragSrc(colorizerSrc) {
    return `
precision highp float;
uniform vec2      u_res;
uniform float     u_zoom;
uniform int       u_maxIter;
uniform sampler2D u_orbit;

${GLSL_HELPERS}

${colorizerSrc}

void main() {
    vec2 uv = (gl_FragCoord.xy / u_res - 0.5) * 2.0;
    uv.x *= u_res.x / u_res.y;

    // Δc = Pixel-Offset vom Referenzpunkt (klein → exakt in float32)
    vec2 dc = uv * (0.5 / u_zoom);

    vec2 dz = vec2(0.0);
    float t  = 0.0;
    bool escaped = false;

    for (int i = 0; i < 4096; i++) {
        if (i >= u_maxIter) break;

        // Referenz-Orbit Z_i aus Textur
        float tx = (float(i) + 0.5) / float(u_maxIter);
        vec2 Z = texture2D(u_orbit, vec2(tx, 0.5)).rg;

        // δ_{n+1} = 2·Z·δ + δ² + Δc
        float dzx = 2.0*(Z.x*dz.x - Z.y*dz.y) + dz.x*dz.x - dz.y*dz.y + dc.x;
        float dzy = 2.0*(Z.x*dz.y + Z.y*dz.x) + 2.0*dz.x*dz.y + dc.y;
        dz = vec2(dzx, dzy);

        float r2 = dot(Z + dz, Z + dz);
        if (r2 > 256.0) {
            float smooth = float(i) + 1.0 - log2(log2(sqrt(r2)));
            t = clamp(smooth / float(u_maxIter), 0.0, 1.0);
            escaped = true;
            break;
        }
    }

    if (!escaped) {
        gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
    } else {
        gl_FragColor = vec4(colorize(t), 1.0);
    }
}`;}

function compilePerturb(colorizerSrc) {
    if (!perturbAvailable) return;
    if (programPerturb) gl.deleteProgram(programPerturb);
    programPerturb = linkProgram(VS_SRC, build2dPerturbFragSrc(colorizerSrc));
}

// ============================================================
// Canvasgröße anpassen (Retina-Support)
// ============================================================
function resizeCanvas() {
    const dpr = window.devicePixelRatio || 1;
    const w = canvas.clientWidth  * dpr;
    const h = canvas.clientHeight * dpr;
    if (canvas.width !== w || canvas.height !== h) {
        canvas.width  = w;
        canvas.height = h;
        gl.viewport(0, 0, w, h);
    }
}

// ============================================================
// 2D rendern
// ============================================================
// Veltkamp-Split: float64 → (hi, lo) als zwei float32
function splitDS(x) {
    const hi = Math.fround(x);
    const lo = Math.fround(x - hi);
    return [hi, lo];
}

function render2d() {
    resizeCanvas();
    const usePerturb = perturbAvailable && isDefaultFormula && orbitValid && programPerturb;

    if (usePerturb) {
        gl.useProgram(programPerturb);
        bindQuad(programPerturb);
        gl.uniform2f(gl.getUniformLocation(programPerturb, 'u_res'), canvas.width, canvas.height);
        gl.uniform1f(gl.getUniformLocation(programPerturb, 'u_zoom'), zoom);
        gl.uniform1i(gl.getUniformLocation(programPerturb, 'u_maxIter'), maxIter2d);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, orbitTex);
        gl.uniform1i(gl.getUniformLocation(programPerturb, 'u_orbit'), 0);
    } else {
        gl.useProgram(program2d);
        bindQuad(program2d);
        gl.uniform2f(gl.getUniformLocation(program2d, 'u_res'), canvas.width, canvas.height);
        const [cxhi, cxlo] = splitDS(center.x);
        const [cyhi, cylo] = splitDS(center.y);
        gl.uniform2f(gl.getUniformLocation(program2d, 'u_cx'), cxhi, cxlo);
        gl.uniform2f(gl.getUniformLocation(program2d, 'u_cy'), cyhi, cylo);
        gl.uniform1f(gl.getUniformLocation(program2d, 'u_zoom'), zoom);
        gl.uniform1i(gl.getUniformLocation(program2d, 'u_maxIter'), maxIter2d);
    }

    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
}

// ============================================================
// Render-Loop
// ============================================================
let needsRender = true;
function renderLoop() {
    if (needsRender) {
        needsRender = false;
        if (currentMode === '2d' && program2d) render2d();
        else if (currentMode === '3d' && program3d) render3d();
    }
    requestAnimationFrame(renderLoop);
}

// ============================================================
// Init
// ============================================================
function init() {
    perturbAvailable = !!gl.getExtension('OES_texture_float');
    initQuad();
    compile2d(DEFAULT_FORMULA, DEFAULT_COLORIZER_2D);
    if (perturbAvailable) {
        compilePerturb(DEFAULT_COLORIZER_2D);
        computeOrbit();
    }
    // Editoren befüllen
    document.getElementById('formula-editor').value = DEFAULT_FORMULA;
    document.getElementById('colorizer-editor-2d').value = DEFAULT_COLORIZER_2D;
    document.getElementById('colorizer-editor-3d').value = DEFAULT_COLORIZER_3D;
    compile3d();
    needsRender = true;
    renderLoop();
    updateInfo();
}

// ============================================================
// 3D-Shader aufbauen
// ============================================================
const DEFAULT_COLORIZER_3D = `vec3 colorize(float t) {
    return hsv2rgb(vec3(t * 2.0 + 0.1, 0.7, pow(t, 0.4)));
}`;

function build3dFragSrc(colorizerSrc, n, maxIter, ao) {
    return `
precision highp float;
uniform vec2  u_res;
uniform vec3  u_camPos;
uniform vec3  u_camTarget;
uniform float u_ao;

${GLSL_HELPERS}

${colorizerSrc}

// ---- Mandelbulb Distance Estimator ----
float DE(vec3 pos) {
    vec3 z = pos;
    float dr = 1.0;
    float r  = 0.0;
    float power = ${n.toFixed(1)};
    for (int i = 0; i < 512; i++) {
        if (i >= ${maxIter}) break;
        r = length(z);
        if (r > 2.0) break;
        float theta = acos(clamp(z.z / r, -1.0, 1.0));
        float phi   = atan(z.y, z.x);
        dr = pow(r, power - 1.0) * power * dr + 1.0;
        float zr = pow(r, power);
        theta *= power;
        phi   *= power;
        z = zr * vec3(sin(theta)*cos(phi),
                      sin(theta)*sin(phi),
                      cos(theta));
        z += pos;
    }
    return 0.5 * log(r) * r / dr;
}

// ---- Normalen via finite Differenzen ----
vec3 calcNormal(vec3 p) {
    float e = 0.001;
    return normalize(vec3(
        DE(p + vec3(e,0,0)) - DE(p - vec3(e,0,0)),
        DE(p + vec3(0,e,0)) - DE(p - vec3(0,e,0)),
        DE(p + vec3(0,0,e)) - DE(p - vec3(0,0,e))
    ));
}

// ---- Ambient Occlusion ----
float calcAO(vec3 p, vec3 n) {
    float ao = 0.0;
    float sc = 1.0;
    for (int i = 1; i <= 5; i++) {
        float hr = 0.02 * float(i);
        ao += sc * (hr - DE(p + n * hr));
        sc *= 0.5;
    }
    return clamp(1.0 - ${ao.toFixed(3)} * ao * 8.0, 0.0, 1.0);
}

// ---- Raymarching ----
float march(vec3 ro, vec3 rd) {
    float t = 0.0;
    for (int i = 0; i < 256; i++) {
        float d = DE(ro + rd * t);
        if (d < 0.0005 * t) return t;
        t += d * 0.75;
        if (t > 8.0) break;
    }
    return -1.0;
}

// ---- Kamera-Matrix ----
mat3 setCamera(vec3 ro, vec3 ta) {
    vec3 cw = normalize(ta - ro);
    vec3 cu = normalize(cross(cw, vec3(0.0, 1.0, 0.0)));
    vec3 cv = cross(cu, cw);
    return mat3(cu, cv, cw);
}

void main() {
    vec2 uv = (gl_FragCoord.xy / u_res - 0.5) * 2.0;
    uv.x *= u_res.x / u_res.y;

    mat3 cam = setCamera(u_camPos, u_camTarget);
    vec3 rd  = normalize(cam * vec3(uv, 1.8));

    float t = march(u_camPos, rd);

    if (t < 0.0) {
        // Hintergrund: dunkler Verlauf
        float grad = clamp(length(uv) * 0.3, 0.0, 1.0);
        gl_FragColor = vec4(mix(vec3(0.02, 0.03, 0.08), vec3(0.0), grad), 1.0);
        return;
    }

    vec3 p  = u_camPos + rd * t;
    vec3 n  = calcNormal(p);
    float ao = calcAO(p, n);

    // Beleuchtung: Key-Light + Fill-Light
    vec3 light1 = normalize(vec3(1.0, 1.5, 1.0));
    vec3 light2 = normalize(vec3(-1.0, 0.5, -0.5));
    float diff1 = max(dot(n, light1), 0.0);
    float diff2 = max(dot(n, light2), 0.0) * 0.3;
    float spec  = pow(max(dot(reflect(-light1, n), -rd), 0.0), 32.0) * 0.5;

    // Escape-Distance als Colorizer-Input
    float de = length(p);
    float tCol = clamp((de - 0.8) * 2.0, 0.0, 1.0);

    vec3 albedo = colorize(tCol);
    vec3 col = albedo * (diff1 + diff2 + 0.15) * ao + vec3(spec);

    gl_FragColor = vec4(clamp(col, 0.0, 1.0), 1.0);
}`;
}

// ============================================================
// 3D kompilieren und rendern
// ============================================================
function compile3d() {
    if (program3d) gl.deleteProgram(program3d);
    program3d = linkProgram(VS_SRC, build3dFragSrc(
        document.getElementById('colorizer-editor-3d').value,
        bulbN, bulbIter, bulbAO
    ));
}

function render3d() {
    resizeCanvas();
    const t0 = performance.now();

    // Kamera-Position aus Spherical Coords
    const camX = camera.dist * Math.sin(camera.theta) * Math.cos(camera.phi);
    const camY = camera.dist * Math.cos(camera.theta);
    const camZ = camera.dist * Math.sin(camera.theta) * Math.sin(camera.phi);

    gl.useProgram(program3d);
    bindQuad(program3d);
    gl.uniform2f(gl.getUniformLocation(program3d, 'u_res'), canvas.width, canvas.height);
    gl.uniform3f(gl.getUniformLocation(program3d, 'u_camPos'), camX, camY, camZ);
    gl.uniform3f(gl.getUniformLocation(program3d, 'u_camTarget'), 0, 0, 0);
    gl.uniform1f(gl.getUniformLocation(program3d, 'u_ao'), bulbAO);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    gl.finish();

    const ms = (performance.now() - t0).toFixed(1);
    document.getElementById('info-render').textContent = ms + ' ms';
}

document.getElementById('apply-3d').addEventListener('click', () => {
    try {
        compile3d();
        showError('error-3d', '');
        needsRender = true;
    } catch (e) {
        showError('error-3d', e.message);
    }
});

// ============================================================
// Tab-Wechsel
// ============================================================
document.querySelectorAll('.tab-btn').forEach(btn => {
    btn.addEventListener('click', () => {
        document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
        btn.classList.add('active');
        document.getElementById(btn.dataset.tab).classList.add('active');
        currentMode = btn.dataset.tab === 'tab2d' ? '2d' : '3d';
        needsRender = true;
    });
});

// ============================================================
// Slider-Werte live anzeigen
// ============================================================
function bindSlider(id, displayId, format) {
    const el = document.getElementById(id);
    const disp = document.getElementById(displayId);
    el.addEventListener('input', () => {
        disp.textContent = format(el.value);
        needsRender = true;
    });
    disp.textContent = format(el.value);
}

bindSlider('max-iter', 'iter-val', v => v);
bindSlider('bulb-n',   'bulb-n-val', v => v);
bindSlider('bulb-iter','bulb-iter-val', v => v);
bindSlider('bulb-ao',  'bulb-ao-val',  v => parseFloat(v).toFixed(2));

document.getElementById('max-iter').addEventListener('input', e => {
    maxIter2d = parseInt(e.target.value);
    computeOrbit();
    needsRender = true;
});
document.getElementById('bulb-n').addEventListener('input', e => {
    bulbN = parseFloat(e.target.value);
    document.getElementById('bulb-n-val').textContent = bulbN;
    try { compile3d(); showError('error-3d', ''); } catch(err) { showError('error-3d', err.message); }
    needsRender = true;
});
document.getElementById('bulb-iter').addEventListener('input', e => {
    bulbIter = parseInt(e.target.value);
    document.getElementById('bulb-iter-val').textContent = bulbIter;
    try { compile3d(); showError('error-3d', ''); } catch(err) { showError('error-3d', err.message); }
    needsRender = true;
});
document.getElementById('bulb-ao').addEventListener('input', e => {
    bulbAO = parseFloat(e.target.value);
    document.getElementById('bulb-ao-val').textContent = bulbAO.toFixed(2);
    try { compile3d(); showError('error-3d', ''); } catch(err) { showError('error-3d', err.message); }
    needsRender = true;
});

// ============================================================
// Apply-Buttons
// ============================================================
function showError(boxId, msg) {
    const box = document.getElementById(boxId);
    box.style.display = msg ? 'block' : 'none';
    box.textContent = msg || '';
}

document.getElementById('apply-2d').addEventListener('click', () => {
    try {
        const formulaSrc   = document.getElementById('formula-editor').value;
        const colorizerSrc = document.getElementById('colorizer-editor-2d').value;
        compile2d(formulaSrc, colorizerSrc);
        isDefaultFormula = (formulaSrc.trim() === DEFAULT_FORMULA.trim());
        if (perturbAvailable) compilePerturb(colorizerSrc);
        showError('error-2d', '');
        needsRender = true;
    } catch (e) {
        showError('error-2d', e.message);
    }
});

// ============================================================
// Formel-Presets
// ============================================================
const PRESETS = {
    'mandelbrot': `vec2 formula(vec2 z, vec2 c) {
    return vec2(z.x*z.x - z.y*z.y + c.x,
                2.0*z.x*z.y        + c.y);
}`,
    'burning-ship': `vec2 formula(vec2 z, vec2 c) {
    float ax = abs(z.x), ay = abs(z.y);
    return vec2(ax*ax - ay*ay + c.x,
                2.0*ax*ay    + c.y);
}`,
    'tricorn': `vec2 formula(vec2 z, vec2 c) {
    // Konjugat von z, dann quadrieren
    return vec2(z.x*z.x - z.y*z.y + c.x,
               -2.0*z.x*z.y       + c.y);
}`,
    'multibrot3': `vec2 formula(vec2 z, vec2 c) {
    // z^3 + c
    float x2 = z.x*z.x, y2 = z.y*z.y;
    return vec2(z.x*(x2 - 3.0*y2) + c.x,
                z.y*(3.0*x2 - y2) + c.y);
}`
};

document.getElementById('preset-select').addEventListener('change', e => {
    const val = e.target.value;
    if (val !== 'custom') {
        document.getElementById('formula-editor').value = PRESETS[val];
    }
    isDefaultFormula = (val === 'mandelbrot');
    needsRender = true;
});

// ============================================================
// 2D-Interaktion: Pan & Zoom
// ============================================================
let isDragging = false;
let lastMouse = { x: 0, y: 0 };

// Pixel (px, py) im logischen Canvas → Komplexe Zahl
function pixelToComplex2(px, py) {
    const w = canvas.clientWidth;
    const h = canvas.clientHeight;
    const ux = (px / w - 0.5) * 2.0 * (w / h);
    const uy = (py / h - 0.5) * 2.0;
    return {
        x: center.x + ux * 0.5 / zoom,
        y: center.y - uy * 0.5 / zoom   // Y invertiert (Canvas-Y nach unten)
    };
}

// ============================================================
// 3D-Kamera: Orbit (Drag) + Zoom (Scroll)
// ============================================================
let isDragging3d = false;
let lastMouse3d = { x: 0, y: 0 };

// Zusammengeführter mousedown für 2D und 3D
canvas.addEventListener('mousedown', e => {
    if (currentMode === '2d') {
        isDragging = true;
        lastMouse = { x: e.clientX, y: e.clientY };
    } else {
        isDragging3d = true;
        lastMouse3d  = { x: e.clientX, y: e.clientY };
    }
    canvas.style.cursor = 'grabbing';
});

window.addEventListener('mouseup', () => {
    isDragging = false;
    isDragging3d = false;
    canvas.style.cursor = 'crosshair';
});

window.addEventListener('mousemove', e => {
    if (currentMode === '3d' && isDragging3d) {
        const dx = e.clientX - lastMouse3d.x;
        const dy = e.clientY - lastMouse3d.y;
        camera.phi   -= dx * 0.005;
        camera.theta -= dy * 0.005;
        camera.theta  = Math.max(0.05, Math.min(Math.PI - 0.05, camera.theta));
        lastMouse3d = { x: e.clientX, y: e.clientY };
        needsRender = true;
        return;
    }
    if (!isDragging || currentMode !== '2d') return;
    const dx = e.clientX - lastMouse.x;
    const dy = e.clientY - lastMouse.y;
    const w = canvas.clientWidth;
    const h = canvas.clientHeight;
    center.x -= dx * (w / h) / w * 1.0 / zoom;
    center.y += dy / h * 1.0 / zoom;
    lastMouse = { x: e.clientX, y: e.clientY };
    computeOrbit();
    updateInfo();
    needsRender = true;
});

canvas.addEventListener('wheel', e => {
    if (currentMode !== '2d') return;
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    const before = pixelToComplex2(mx, my);
    const factor = e.deltaY < 0 ? 1.15 : (1.0 / 1.15);
    zoom *= factor;
    const after = pixelToComplex2(mx, my);
    center.x += before.x - after.x;
    center.y += before.y - after.y;
    updateInfo();
    needsRender = true;
}, { passive: false });

canvas.addEventListener('wheel', e => {
    if (currentMode !== '3d') return;
    e.preventDefault();
    camera.dist *= e.deltaY < 0 ? 0.92 : 1.08;
    camera.dist  = Math.max(1.1, Math.min(8.0, camera.dist));
    needsRender  = true;
}, { passive: false });

canvas.addEventListener('dblclick', e => {
    if (currentMode !== '2d') return;
    const rect = canvas.getBoundingClientRect();
    const p = pixelToComplex2(e.clientX - rect.left, e.clientY - rect.top);
    center = p;
    zoom *= 2.0;
    computeOrbit();
    updateInfo();
    needsRender = true;
});

// ============================================================
// Info-Panel aktualisieren
// ============================================================
function updateInfo() {
    document.getElementById('info-re').textContent   = center.x.toExponential(4);
    document.getElementById('info-im').textContent   = center.y.toExponential(4);
    document.getElementById('info-zoom').textContent = zoom.toExponential(3);
}

window.addEventListener('load', init);
window.addEventListener('resize', () => { needsRender = true; });
</script>
</body>
</html>
